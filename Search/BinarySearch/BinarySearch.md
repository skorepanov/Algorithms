# Binary search - Бинарный (двоичный) поиск

Алгоритм "разделяй и властвуй".

## Сложность алгоритма

- Time complexity.
  - В худшем случае и в среднем: `O(log(n))`.
  - В лучшем случае: `O(1)`.
- Space complexity: `O(1)`.

## Описание алгоритма

- На каждом шагу берётся число в середине диапазона и исключается половина оставшихся чисел.
- Список должен быть отсортирован.
- В общем случае для списка из n элементов поиск будет выполнен за `log2(n)` шагов.
- Подходит для очень больших массивов.
- Как правило, интерполяционный поиск быстрее бинарного.

## Варианты алгоритма

### Вариант 1: left <= right

- Наиболее базовый и элементарный.
- Не требует постобработки.
- Подходит, когда надо найти что-то конкретное.
  - Примеры:
    - Найти наименьший или наибольший элемент в отсортированном сдвинутом массиве.
    - Найти начальную и конечную позицию данного числа в отсортированном массиве.
    - Найти квадратный корень из данного числа.

### Вариант 2: left < right

- Усовершенствованная версия варианта 1.
- Гарантируется, что размер поискового пространства на каждом этапе будет не менее 2.
- Требует постобработки, т.к. цикл завершается, когда остаётся 1 элемент.
  - Необходимо проверить, соответствует ли он условию.
    - Т.е. во втором варианте не будет лишнего выполнения тела цикла, но добавится постусловие.
- Подходит, когда надо найти наиболее подходящее значение.
  - Примеры:
    - Найти в отсортированном массиве наименьший элемент, превышающий данное число.
    - Найти минимальный элемент в отсортированном сдвинутом (rotated) массиве.

### Вариант 3: left + 1 < right

- Альтернативная версия бинарного поиска.
- Гарантируется, что размер поискового пространства на каждом этапе будет не менее 3.
- Требует постобработки, т.к. цикл завершается, когда остаётся 2 элемента.
  - Необходимо проверить, соответствуют ли они условию.
    - Т.е. в третьем варианте не будет двух лишних выполнений тела цикла, но добавится два постусловия.
- В теле цикла не будет такого, что `left == middle`.
  - Это даёт возможность брать предыдущий элемент: `list[middle - 1] == target`.
- Подходит, когда надо найти наиболее подходящее значение.
  - Примеры:
    - Найти в отсортированном массиве элемент, ближайший к данному числу (по модулю).
