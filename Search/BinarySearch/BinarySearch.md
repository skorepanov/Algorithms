# Binary search - Бинарный (двоичный) поиск

Алгоритм "разделяй и властвуй".

## Сложность алгоритма

- Временная сложность.
  - В худшем случае и в среднем: `O(log(n))`.
  - В лучшем случае: `O(1)`.
- Затраты памяти: `O(1)`.

## Описание алгоритма

- На каждом шагу берётся число в середине диапазона и исключается половина оставшихся чисел.
- Список должен быть отсортирован.
- В общем случае для списка из n элементов поиск будет выполнен за `log2(n)` шагов.
- Подходит для очень больших массивов.
- Как правило, интерполяционный поиск быстрее бинарного.

## Варианты алгоритма

### Вариант 1: left <= right

- Наиболее базовый и элементарный.
- Не требует постобработки.

### Вариант 2: left < right

- Усовершенствованная версия варианта 1.
- Гарантируется, что размер поискового пространства на каждом этапе будет не менее 2.
- Требует постобработки, т.к. цикл завершается, когда остаётся 1 элемент.
  - Необходимо проверить, соответствует ли он условию.
    - Т.е. во втором варианте не будет лишнего выполнения тела цикла, но добавится постусловие.

### Вариант 3: left + 1 < right

- Альтернативная версия бинарного поиска.
- Гарантируется, что размер поискового пространства на каждом этапе будет не менее 3.
- Требует постобработки, т.к. цикл завершается, когда остаётся 2 элемента.
  - Необходимо проверить, соответствуют ли они условию.
    - Т.е. в третьем варианте не будет двух лишних выполнений тела цикла, но добавится два постусловия.
- В теле цикла не будет такого, что `left == middle`.
  - Это даёт возможность брать предыдущий элемент: `list[middle - 1] == target`.
